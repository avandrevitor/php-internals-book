

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Casts and operations &mdash; PHP Internals Book</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="PHP Internals Book" href="../index.html" />
    <link rel="up" title="Zvals" href="../zvals.html" />
    <link rel="next" title="Hashtables" href="../hashtables.html" />
    <link rel="prev" title="Memory management" href="memory_management.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Casts and operations</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../hashtables.html">Hashtables</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="casts-and-operations">
<h1>Casts and operations<a class="headerlink" href="#casts-and-operations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="basic-operations">
<h2>Basic operations<a class="headerlink" href="#basic-operations" title="Permalink to this headline">¶</a></h2>
<p>As zvals are complex structures you can&#8217;t directly perform basic operations like <tt class="docutils literal"><span class="pre">zv1</span> <span class="pre">+</span> <span class="pre">zv2</span></tt> on them. Doing something
like this will either give you an error or end up adding together two pointers rather than their values.</p>
<p>The &#8220;basic&#8221; operations like <tt class="docutils literal"><span class="pre">+</span></tt> are rather complicated when working with zvals, because they have to work across
many types. For example PHP allows you to add together a double with a string containing an integer (<tt class="docutils literal"><span class="pre">3.14</span> <span class="pre">+</span> <span class="pre">&quot;17&quot;</span></tt>)
or even adding two arrays (<tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span> <span class="pre">+</span> <span class="pre">[4,</span> <span class="pre">5,</span> <span class="pre">6]</span></tt>).</p>
<p>For this reason PHP provides special functions for performing operations on zvals. Addition for example is handled by
<tt class="docutils literal"><span class="pre">add_function()</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

<span class="n">ZVAL_DOUBLE</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;17&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cm">/* result = a + b */</span>
<span class="n">add_function</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%Z</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span> <span class="cm">/* 20.14 */</span>

<span class="cm">/* zvals a, b, result need to be dtored */</span>
</pre></div>
</div>
<p>Apart from <tt class="docutils literal"><span class="pre">add_function()</span></tt> there are several other functions implementing binary (two-operand) operations, all with
the same signature:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">add_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>                 <span class="cm">/*  +  */</span>
<span class="kt">int</span> <span class="nf">sub_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>                 <span class="cm">/*  -  */</span>
<span class="kt">int</span> <span class="nf">mul_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>                 <span class="cm">/*  *  */</span>
<span class="kt">int</span> <span class="nf">div_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>                 <span class="cm">/*  /  */</span>
<span class="kt">int</span> <span class="nf">mod_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>                 <span class="cm">/*  %  */</span>
<span class="kt">int</span> <span class="nf">concat_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>              <span class="cm">/*  .  */</span>
<span class="kt">int</span> <span class="nf">bitwise_or_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>          <span class="cm">/*  |  */</span>
<span class="kt">int</span> <span class="nf">bitwise_and_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>         <span class="cm">/*  &amp;  */</span>
<span class="kt">int</span> <span class="nf">bitwise_xor_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>         <span class="cm">/*  ^  */</span>
<span class="kt">int</span> <span class="nf">shift_left_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>          <span class="cm">/*  &lt;&lt; */</span>
<span class="kt">int</span> <span class="nf">shift_right_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>         <span class="cm">/*  &gt;&gt; */</span>
<span class="kt">int</span> <span class="nf">boolean_xor_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>         <span class="cm">/* xor */</span>
<span class="kt">int</span> <span class="nf">is_equal_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>            <span class="cm">/*  == */</span>
<span class="kt">int</span> <span class="nf">is_not_equal_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>        <span class="cm">/*  != */</span>
<span class="kt">int</span> <span class="nf">is_identical_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>        <span class="cm">/* === */</span>
<span class="kt">int</span> <span class="nf">is_not_identical_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>    <span class="cm">/* !== */</span>
<span class="kt">int</span> <span class="nf">is_smaller_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>          <span class="cm">/*  &lt;  */</span>
<span class="kt">int</span> <span class="nf">is_smaller_or_equal_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span> <span class="cm">/*  &lt;= */</span>
</pre></div>
</div>
<p>All functions take a <tt class="docutils literal"><span class="pre">result</span></tt> zval into which the result of the operation on <tt class="docutils literal"><span class="pre">op1</span></tt> and <tt class="docutils literal"><span class="pre">op2</span></tt> is stored. The
<tt class="docutils literal"><span class="pre">int</span></tt> return value is either <tt class="docutils literal"><span class="pre">SUCCESS</span></tt> or <tt class="docutils literal"><span class="pre">FAILURE</span></tt> and indicates whether the operation was successful. Note that
<tt class="docutils literal"><span class="pre">result</span></tt> will always be set to some value (like <tt class="docutils literal"><span class="pre">false</span></tt>) even if the operations was not successful.</p>
<p>The <tt class="docutils literal"><span class="pre">result</span></tt> zval needs to be allocated and initialized prior to calling one of the functions. Alternatively
<tt class="docutils literal"><span class="pre">result</span></tt> and <tt class="docutils literal"><span class="pre">op1</span></tt> can be the same, in which case effectively a compound assignment operation is performed:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

<span class="n">ZVAL_LONG</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;3&quot;</span><span class="p">);</span>

<span class="cm">/* a += b */</span>
<span class="n">add_function</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%Z</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="cm">/* 45 */</span>

<span class="cm">/* zvals a, b need to be dtored */</span>
</pre></div>
</div>
<p>Some binary operators are missing from the above list. For example there are no functions for <tt class="docutils literal"><span class="pre">&gt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;=</span></tt>. The
reason behind this is that you can implement them using <tt class="docutils literal"><span class="pre">is_smaller_function()</span></tt> and <tt class="docutils literal"><span class="pre">is_smaller_or_equal_function()</span></tt>
simply by swapping the operands.</p>
<p>Also missing from the list are functions for performing <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt>. The reasoning here is that the main feature
those operators provide is short-circuiting, which you can&#8217;t implement with a simple function. If you take
short-circuiting away, both operators are just boolean casts followed by a <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> or <tt class="docutils literal"><span class="pre">||</span></tt> C-operation.</p>
<p>Apart from the binary operators there are also two unary (single operand) functions:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">boolean_not_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span> <span class="n">TSRMLS_DC</span><span class="p">);</span> <span class="cm">/*  !  */</span>
<span class="kt">int</span> <span class="nf">bitwise_not_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span> <span class="n">TSRMLS_DC</span><span class="p">);</span> <span class="cm">/*  ~  */</span>
</pre></div>
</div>
<p>They work in the same way the other functions, but accept only one operand. The unary <tt class="docutils literal"><span class="pre">+</span></tt> and <tt class="docutils literal"><span class="pre">-</span></tt> operations are
missing, because they can be implemented as <tt class="docutils literal"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">$value</span></tt> and <tt class="docutils literal"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">$value</span></tt> respectively, by making use of
<tt class="docutils literal"><span class="pre">add_function()</span></tt> and <tt class="docutils literal"><span class="pre">sub_function()</span></tt>.</p>
<p>The last two functions implement the <tt class="docutils literal"><span class="pre">++</span></tt> and <tt class="docutils literal"><span class="pre">--</span></tt> operators:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">increment_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">);</span> <span class="cm">/* ++ */</span>
<span class="kt">int</span> <span class="nf">decrement_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">);</span> <span class="cm">/* -- */</span>
</pre></div>
</div>
<p>These functions don&#8217;t take a result zval and instead directly modify the passed operand. Note that using these is
different from performing a <tt class="docutils literal"><span class="pre">+</span> <span class="pre">1</span></tt> or <tt class="docutils literal"><span class="pre">-</span> <span class="pre">1</span></tt> with <tt class="docutils literal"><span class="pre">add_function()</span></tt>/<tt class="docutils literal"><span class="pre">sub_function()</span></tt>. For example incrementing
<tt class="docutils literal"><span class="pre">&quot;a&quot;</span></tt> will result in <tt class="docutils literal"><span class="pre">&quot;b&quot;</span></tt>, but adding <tt class="docutils literal"><span class="pre">&quot;a&quot;</span> <span class="pre">+</span> <span class="pre">1</span></tt> will result in <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
</div>
<div class="section" id="comparisons">
<h2>Comparisons<a class="headerlink" href="#comparisons" title="Permalink to this headline">¶</a></h2>
<p>The comparison functions introduced above all perform some specific operation, e.g. <tt class="docutils literal"><span class="pre">is_equal_function()</span></tt> corresponds
to <tt class="docutils literal"><span class="pre">==</span></tt> and <tt class="docutils literal"><span class="pre">is_smaller_function()</span></tt> performs a <tt class="docutils literal"><span class="pre">&lt;</span></tt>. An alternative to these is <tt class="docutils literal"><span class="pre">compare_function()</span></tt> which
computes a more generic result:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

<span class="n">ZVAL_LONG</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s">&quot;24&quot;</span><span class="p">);</span>

<span class="n">compare_function</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">TSRMLS_CC</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;a is smaller than b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;a is greater than b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="cm">/*if (Z_LVAL_P(result) == 0)*/</span> <span class="p">{</span>
    <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;a is equal to b</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* zvals a, b, result need to be dtored */</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">compare_function()</span></tt> will set the <tt class="docutils literal"><span class="pre">result</span></tt> zval to one of -1, 1 or 0 corresponding to the relations &#8220;smaller than&#8221;,
&#8220;greater than&#8221; or &#8220;equal&#8221; between the passed values. It is also part of a larger family of comparison functions:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">compare_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">numeric_compare_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">string_compare_function_ex</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span><span class="p">,</span> <span class="n">zend_bool</span> <span class="n">case_insensitive</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">string_compare_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">string_case_compare_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>

<span class="cp">#ifdef HAVE_STRCOLL</span>
<span class="kt">int</span> <span class="nf">string_locale_compare_function</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op1</span><span class="p">,</span> <span class="n">zval</span> <span class="o">*</span><span class="n">op2</span> <span class="n">TSRMLS_DC</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Once again all functions accept two operands and a result zval and return <tt class="docutils literal"><span class="pre">SUCCESS</span></tt>/<tt class="docutils literal"><span class="pre">FAILURE</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">compare_function()</span></tt> performs a &#8220;normal&#8221; PHP comparison (i.e. it behaves the same way as the <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt> and <tt class="docutils literal"><span class="pre">==</span></tt>
operators). <tt class="docutils literal"><span class="pre">numeric_compare_function()</span></tt> compares the operands as numbers by casting them to doubles first.</p>
<p><tt class="docutils literal"><span class="pre">string_compare_function_ex()</span></tt> compares the operands as strings and has a flag that indicates whether the comparison
should be <tt class="docutils literal"><span class="pre">case_insensitive</span></tt>. Instead of manually specifying that flag you can also use
<tt class="docutils literal"><span class="pre">string_compare_function()</span></tt> (case sensitive) or <tt class="docutils literal"><span class="pre">string_case_compare_function()</span></tt> (case insensitive). The string
comparison done by these functions is a normal lexicographical string comparison without additional magic for numeric
strings.</p>
<p><tt class="docutils literal"><span class="pre">string_locale_compare_function()</span></tt> performs a string comparison according to the current locale and is only available
if <tt class="docutils literal"><span class="pre">HAVE_STRCOLL</span></tt> is defined. As such you must use <tt class="docutils literal"><span class="pre">#ifdef</span> <span class="pre">HAVE_STRCOLL</span></tt> guards whenever you employ the function.
As with anything related to locales, it&#8217;s best to avoid its use.</p>
</div>
<div class="section" id="casts">
<h2>Casts<a class="headerlink" href="#casts" title="Permalink to this headline">¶</a></h2>
<p>When implementing your own code you will very often deal with only one particular type of zval. E.g. if you are
implementing some string handling code, you&#8217;ll want to deal only with string zvals and not bother with everything else.
On the other hand you likely also want to support PHPs dynamic type system: PHP allows you to work with numbers as
strings and extension code should honor this as well.</p>
<p>The solution is to cast a zval of arbitrary type to the specific type you&#8217;ll be working with. In order to support this
PHP provides a <tt class="docutils literal"><span class="pre">convert_to_*</span></tt> function for every type (apart from resources, as there is no <tt class="docutils literal"><span class="pre">(resource)</span></tt> cast):</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">convert_to_null</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_boolean</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_long</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_double</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_string</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_array</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_object</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">convert_to_long_base</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_cstring</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>The last two functions implement non-standard casts: <tt class="docutils literal"><span class="pre">convert_to_long_base()</span></tt> is the same as <tt class="docutils literal"><span class="pre">convert_to_long()</span></tt>,
but it will make use of a particular base for string to long conversions (e.g. <tt class="docutils literal"><span class="pre">16</span></tt> for hexadecimals).
<tt class="docutils literal"><span class="pre">convert_to_cstring()</span></tt> behaves like <tt class="docutils literal"><span class="pre">convert_to_string()</span></tt> but uses a locale-independent double to string conversion.
This means that the result will always use <tt class="docutils literal"><span class="pre">.</span></tt> as the decimal separator rather than creating locale-specific strings
like <tt class="docutils literal"><span class="pre">&quot;3,14&quot;</span></tt> (Germany).</p>
<p>The <tt class="docutils literal"><span class="pre">convert_to_*</span></tt> functions will directly modify the passed zval:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span> <span class="s">&quot;123 foobar&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">convert_to_long</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">));</span>

<span class="n">zval_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>If the zval is used in more than one place (refcount &gt; 1) chances are that directly modifying it would result in
incorrect behavior. E.g. if you receive a zval by-value and directly apply a <tt class="docutils literal"><span class="pre">convert_to_*</span></tt> function to it, you will
modify not only the reference to the zval inside the function but also the reference outside of it.</p>
<p>To solve this issue PHP provides an additional set of <tt class="docutils literal"><span class="pre">convert_to_*_ex</span></tt> macros:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">convert_to_null_ex</span><span class="p">(</span><span class="n">zval</span> <span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_boolean_ex</span><span class="p">(</span><span class="n">zval</span> <span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_long_ex</span><span class="p">(</span><span class="n">zval</span> <span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_double_ex</span><span class="p">(</span><span class="n">zval</span> <span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_string_ex</span><span class="p">(</span><span class="n">zval</span> <span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_array_ex</span><span class="p">(</span><span class="n">zval</span> <span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">convert_to_object_ex</span><span class="p">(</span><span class="n">zval</span> <span class="o">**</span><span class="n">ppzv</span><span class="p">);</span>
</pre></div>
</div>
<p>These macros take a <tt class="docutils literal"><span class="pre">zval**</span></tt> and are implemented by performing a <tt class="docutils literal"><span class="pre">SEPARATE_ZVAL_IF_NOT_REF()</span></tt> before the type
conversion:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define convert_to_ex_master(ppzv, lower_type, upper_type)  \</span>
<span class="cp">    if (Z_TYPE_PP(ppzv)!=IS_##upper_type) {                 \</span>
<span class="cp">        SEPARATE_ZVAL_IF_NOT_REF(ppzv);                     \</span>
<span class="cp">        convert_to_##lower_type(*ppzv);                     \</span>
<span class="cp">    }</span>
</pre></div>
</div>
<p>Apart from this the usage is similar to the normal <tt class="docutils literal"><span class="pre">convert_to_*</span></tt> functions:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">**</span><span class="n">zv_ptr_ptr</span> <span class="o">=</span> <span class="cm">/* get function argument */</span><span class="p">;</span>

<span class="n">convert_to_long_ex</span><span class="p">(</span><span class="n">zv_ptr_ptr</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Z_LVAL_PP</span><span class="p">(</span><span class="n">zv_ptr_ptr</span><span class="p">));</span>

<span class="cm">/* No need to dtor as function arguments are dtored automatically */</span>
</pre></div>
</div>
<p>But even this will not always be enough. Lets consider a very similar case where a value is fetched from an array:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">array_zv</span> <span class="o">=</span> <span class="cm">/* get array from somewhere */</span><span class="p">;</span>

<span class="cm">/* Fetch array index 42 into zv_dest (how this works is not relevant here) */</span>
<span class="n">zval</span> <span class="o">**</span><span class="n">zv_dest</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">zend_hash_index_find</span><span class="p">(</span><span class="n">Z_ARRVAL_P</span><span class="p">(</span><span class="n">array_zv</span><span class="p">),</span> <span class="mi">42</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">zv_dest</span><span class="p">)</span> <span class="o">==</span> <span class="n">FAILURE</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Error: Index not found */</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">convert_to_long_ex</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Z_LVAL_PP</span><span class="p">(</span><span class="n">zv_dest</span><span class="p">));</span>

<span class="cm">/* No need to dtor because array values are dtored automatically */</span>
</pre></div>
</div>
<p>The use of <tt class="docutils literal"><span class="pre">convert_to_long_ex()</span></tt> in the above code will prevent modification of references to the value outside the
array, but it will still change the value inside the array itself. In some cases this is the correct behavior, but
typically you want to avoid modifying the array when fetching values from it.</p>
<p>In cases like these there is no way around copying the zval before converting it:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">**</span><span class="n">zv_dest</span> <span class="o">=</span> <span class="cm">/* get array value */</span><span class="p">;</span>
<span class="n">zval</span> <span class="n">tmp_zv</span><span class="p">;</span>

<span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">,</span> <span class="o">*</span><span class="n">zv_dest</span><span class="p">);</span>
<span class="n">zval_copy_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">);</span>

<span class="n">convert_to_long</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Z_LVAL</span><span class="p">(</span><span class="n">tmp_zv</span><span class="p">));</span>

<span class="n">zval_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">);</span>
</pre></div>
</div>
<p>The last <tt class="docutils literal"><span class="pre">zval_dtor()</span></tt> call in the above code is not strictly necessary, because we know that <tt class="docutils literal"><span class="pre">tmp_zv</span></tt> will be
of type <tt class="docutils literal"><span class="pre">IS_LONG</span></tt>, which is a type that does not require destruction. For conversions to other types like strings or
arrays the dtor call is necessary though.</p>
<p>If the use of to-long or to-double conversions is common in your code, it can make sense to create helper functions which
perform casts without modifying any zval. A sample implementation for long casts:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">long</span> <span class="nf">zval_get_long</span><span class="p">(</span><span class="n">zval</span> <span class="o">*</span><span class="n">zv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">zv</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">IS_NULL</span>:
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">IS_BOOL</span>:
        <span class="k">case</span> <span class="n">IS_LONG</span>:
        <span class="k">case</span> <span class="n">IS_RESOURCE</span>:
            <span class="k">return</span> <span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">IS_DOUBLE</span>:
            <span class="k">return</span> <span class="n">zend_dval_to_lval</span><span class="p">(</span><span class="n">Z_DVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">));</span>
        <span class="k">case</span> <span class="n">IS_STRING</span>:
            <span class="k">return</span> <span class="n">strtol</span><span class="p">(</span><span class="n">Z_STRVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">IS_ARRAY</span>:
            <span class="k">return</span> <span class="n">zend_hash_num_elements</span><span class="p">(</span><span class="n">Z_ARRVAL_P</span><span class="p">(</span><span class="n">zv</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">IS_OBJECT</span>: <span class="p">{</span>
            <span class="n">zval</span> <span class="n">tmp_zv</span><span class="p">;</span>
            <span class="n">ZVAL_COPY_VALUE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zv</span><span class="p">,</span> <span class="n">zv</span><span class="p">);</span>
            <span class="n">zval_copy_ctor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
            <span class="n">convert_to_long_base</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">tmp_zv</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above code will directly return the result of the cast without performing any zval copies (apart from the
<tt class="docutils literal"><span class="pre">IS_OBJECT</span></tt> case where the copy is unavoidable). By making use of the function the array value cast example becomes
much simpler:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">**</span><span class="n">zv_dest</span> <span class="o">=</span> <span class="cm">/* get array value */</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">lval</span> <span class="o">=</span> <span class="n">zval_get_long</span><span class="p">(</span><span class="o">*</span><span class="n">zv_dest</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lval</span><span class="p">);</span>
</pre></div>
</div>
<p>PHPs standard library already contains one function of this type, namely <tt class="docutils literal"><span class="pre">zend_is_true()</span></tt>. This function is
functionally equivalent to a bool cast from which the value is returned directly:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>

<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">zend_is_true</span><span class="p">(</span><span class="n">zv</span><span class="p">));</span> <span class="c1">// 0</span>
<span class="n">zval_dtor</span><span class="p">(</span><span class="n">zv</span><span class="p">);</span>

<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="s">&quot;foobar&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">zend_is_true</span><span class="p">(</span><span class="n">zv</span><span class="p">));</span> <span class="c1">// 1</span>
<span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv</span><span class="p">);</span>
</pre></div>
</div>
<p>Another function which avoids unnecessary copies during casting is <tt class="docutils literal"><span class="pre">zend_make_printable_zval()</span></tt>. This function
performs the same string cast as <tt class="docutils literal"><span class="pre">convert_to_string()</span></tt> but makes use of a different API. The typical usage is as
follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">zv_ptr</span> <span class="o">=</span> <span class="cm">/* get zval from somewhere */</span><span class="p">;</span>

<span class="n">zval</span> <span class="n">tmp_zval</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tmp_zval_used</span><span class="p">;</span>
<span class="n">zend_make_printable_zval</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_zval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_zval_used</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">tmp_zval_used</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">zv_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_zval</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PHPWRITE</span><span class="p">(</span><span class="n">Z_STRVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">),</span> <span class="n">Z_STRLEN_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">));</span>

<span class="k">if</span> <span class="p">(</span><span class="n">tmp_zval_used</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">zval_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_zval</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second parameter to this function is a pointer to a temporary zval and the third parameter is a pointer to an
integer. If the function makes use of the temporary zval, the integer will be set to one, zero otherwise.</p>
<p>Based on <tt class="docutils literal"><span class="pre">tmp_zval_used</span></tt> you can then decide whether to use the original zval or the temporary copy. Very commonly
the temporary zval is simply assigned to the original zval using <tt class="docutils literal"><span class="pre">zv_ptr</span> <span class="pre">=</span> <span class="pre">&amp;tmp_zval</span></tt>. This allows you to always work
with <tt class="docutils literal"><span class="pre">zv_ptr</span></tt> rather than having conditionals everywhere to choose between the two.</p>
<p>Finally you need to dtor the temporary zval using <tt class="docutils literal"><span class="pre">zval_dtor(&amp;tmp_zval)</span></tt>, but only if it was actually used.</p>
<p>Another function that is related to casting is <tt class="docutils literal"><span class="pre">is_numeric_string()</span></tt>. This function checks whether a string is
&#8220;numeric&#8221; and extracts the value into either a long or a double:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">long</span> <span class="n">lval</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">dval</span><span class="p">;</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">is_numeric_string</span><span class="p">(</span><span class="n">Z_STRVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">),</span> <span class="n">Z_STRLEN_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dval</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">IS_LONG</span>:
        <span class="cm">/* String is an integer those value was put into `lval` */</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">IS_DOUBLE</span>:
        <span class="cm">/* String is a double those value was put into `dval` */</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="cm">/* String is not numeric */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The last argument to this function is called <tt class="docutils literal"><span class="pre">allow_errors</span></tt>. Setting it to <tt class="docutils literal"><span class="pre">0</span></tt> will reject strings like
<tt class="docutils literal"><span class="pre">&quot;123abc&quot;</span></tt>, whereas setting it to <tt class="docutils literal"><span class="pre">1</span></tt> will silently allow them (with value <tt class="docutils literal"><span class="pre">123</span></tt>). A third value <tt class="docutils literal"><span class="pre">-1</span></tt> provides
an intermediate solution, which accepts the string, but throws a notice.</p>
<p>It is helpful to know that this function also accepts hexadecimal numbers in the <tt class="docutils literal"><span class="pre">0xabc</span></tt> format. In this it differs
from <tt class="docutils literal"><span class="pre">convert_to_long()</span></tt> and <tt class="docutils literal"><span class="pre">convert_to_double()</span></tt> which would cast <tt class="docutils literal"><span class="pre">&quot;0xabc&quot;</span></tt> to zero.</p>
<p><tt class="docutils literal"><span class="pre">is_numeric_string()</span></tt> is particularly useful in cases where you can work with both integer and floating point numbers,
but don&#8217;t want to incur the precision loss associated with using doubles for both cases. To help this use case, there
is an additional <tt class="docutils literal"><span class="pre">convert_scalar_to_number()</span></tt> function, which accepts a zval and converts non-array values to either
a long or a double (using <tt class="docutils literal"><span class="pre">is_numeric_string()</span></tt> for strings). This means that the converted zval will have type
<tt class="docutils literal"><span class="pre">IS_LONG</span></tt>, <tt class="docutils literal"><span class="pre">IS_DOUBLE</span></tt> or <tt class="docutils literal"><span class="pre">IS_ARRAY</span></tt>. The usage is the same as for the <tt class="docutils literal"><span class="pre">convert_to_*()</span></tt> functions:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="o">*</span><span class="n">zv_ptr</span><span class="p">;</span>
<span class="n">MAKE_STD_ZVAL</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="n">ZVAL_STRING</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">,</span> <span class="s">&quot;3.141&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">convert_scalar_to_number</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">);</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">Z_TYPE_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">IS_LONG</span>:
        <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Long: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Z_LVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">));</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">IS_DOUBLE</span>:
        <span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Double: %G</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Z_DVAL_P</span><span class="p">(</span><span class="n">zv_ptr</span><span class="p">));</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">IS_ARRAY</span>:
        <span class="cm">/* Likely throw an error here */</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">zval_ptr_dtor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zv_ptr</span><span class="p">);</span>

<span class="cm">/* Double: 3.141 */</span>
</pre></div>
</div>
<p>Once again there also is a <tt class="docutils literal"><span class="pre">convert_scalar_to_number_ex()</span></tt> variant of this function, which accepts a <tt class="docutils literal"><span class="pre">zval**</span></tt> and
will separate it before the conversion.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="memory_management.html">Memory management</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../hashtables.html">Hashtables</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer feedback">
        Send feedback to <a href="mailto:feedback@phpinternalsbook.com">feedback@phpinternalsbook.com</a>
    </div>
    
    <div class="footer">
        &copy; Copyright 2013, Julien Pauli - Anthony Ferrara - Nikita Popov.
    </div>
    <div class="footer feedback">
        All Rights Reserved
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>